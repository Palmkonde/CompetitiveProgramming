#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct TUPLE{int u;int v;int w;}tuple;tuple maketuple(int a,int b, int c){tuple new;new.u = a;new.v = b;new.w = c;return new;}tuple edge[400005];int n,m,k;int parent[100005],h[100005];int Tree[100005], Tsize;void push(int x){Tree[Tsize++] = x;int node = Tsize-1;int p;int tmp = Tree[node];while(node > 0){p = (node-1)/2;if(Tree[p] > tmp) break;Tree[node] = Tree[p];node = p;}Tree[node] = tmp;}void pop(){Tree[0] = Tree[--Tsize];int node = 0;int c;int tmp = Tree[node];while((c = 2*node+1) < Tsize){if(c + 1 < Tsize && Tree[c+1] > Tree[c]){c++;}if(tmp > Tree[c]){break;}Tree[node] = Tree[c];node = c;}Tree[node] = tmp;}void merge(int l,int r){if(l >= r) return;int mid = l + (r-l)/2;merge(l,mid);merge(mid+1,r);int n1 = mid-l+1;int n2 = r-mid;tuple tmp1[n1],tmp2[n2];for(int i=0;i<n1;i++) tmp1[i] = edge[l+i];for(int i=0;i<n2;i++) tmp2[i] = edge[mid+i+1];int i,j,k;i = j = 0;k = l;while(i < n1 && j < n2){if(tmp1[i].w <= tmp2[j].w){edge[k++] = tmp1[i++];}else {edge[k++] = tmp2[j++];}}while(i < n1) {edge[k++] = tmp1[i++];}while(j < n2) {edge[k++] = tmp2[j++];}}int root(int x){if(parent[x] == -1){return x;}else{return parent[x] = root(parent[x]);}}void swap(int *x,int *y){int t;t = *x;*x = *y;*y = t;}int main(){scanf("%d %d %d",&n,&m,&k);memset(parent, -1, sizeof(parent));for(int i=0;i<=n;i++){h[i] = 1;}int a,b,c;for(int i=0;i<m;i++){scanf("%d %d %d",&a,&b,&c);edge[i] = maketuple(a,b,c);}merge(0,m-1);int ans = 0;for(int i=0;i<m;i++){int pa = root(edge[i].u);int pb = root(edge[i].v);if(pa != pb){if(h[pa] < h[pb]){swap(&pa,&pb);}h[pa] += h[pb];parent[pb] = pa;push(edge[i].w);}}while(k--){int tmp = Tree[0];pop();push(tmp * 0.5);}while(Tsize){ans += Tree[0];pop();}printf("%d",ans);return 0;}